\documentclass{llncs}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled]{beramono}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{microtype}
\usepackage{prooftree}
\usepackage{tgpagella}
\usepackage{xspace}

\author{Dominic P. Mulligan}
\title{Mosquito: an implementation of higher-order logic}
\subtitle{(Rough diamond)}
\titlerunning{Mosquito}
\institute{Computer Laboratory, University of Cambridge}

\newcommand{\act}{\cdot}
\newcommand{\aeq}{=_\alpha}
\newcommand{\deffont}[1]{\textbf{#1}}
\newcommand{\ent}{\vdash}
\newcommand{\lam}[1]{\lambda{#1}.}
\newcommand{\mosquito}{Mosquito\xspace}
\newcommand{\rulefont}[1]{\ensuremath{(\mathbf{#1})}}
\newcommand{\tf}[1]{\mathsf{#1}}

\bibliographystyle{alpha}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=haskell,                 % the language of the code
  mathescape=true,
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  belowskip=-1.125\baselineskip
}

\begin{document}

\maketitle

\begin{abstract}
We present \mosquito, a stateless, pure, largely total LCF-style implementation of classical higher-order logic with choice in Haskell.
We discuss details of the logic implemented, the kernel design and proof state and tactic representations.
We present some simple tactic-guided backwards proofs of conjectures over the Booleans in the system.
\end{abstract}

\section{Introduction}
\label{sect.introduction}

\mosquito is an implementation of higher-order logic (HOL) written in Haskell.

Existing LCF-style implementations written in ML such as HOL4~\cite{gordon:introduction:1993}, HOL Light~\cite{harrison:hol:2009} and Isabelle~\cite{wenzel:isabelle:2008} intrinsically rely on state within their kernels.
When extending the logic with new constant definitions, care must be taken to ensure that constants are not defined twice, lest, as pointed out by Wiedijk~\cite{wiedijk:stateless:2011}, an inconsistency occur by defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$, then deducing $\mathtt{0 = 1}$ by transitivity and symmetry of equality.
This, in the systems mentioned above, is managed by a stateful kernel wherein an imperative database of existing constant names is maintained thus preventing the redefinition of existing constants.

Prevailing programming style within the Haskell community tends to avoid the use of imperative update and maintenance of implicit state, where possible.
Rather, explicit state tends to be passed around, with a monadic style of programming used to assuage the pain associated with such a programming style.
However, a na\"ive translation of an existing LCF-style kernel to Haskell using explicit state passing would be prone to inconsistencies without careful management of the many versions of the immutable state object floating around the system.
A na\"ive translation would also radically change the \textsc{api} of the kernel presented to the programmer, making it much more cumbersome to use than the kernels of existing systems.

As Wiedijk noted, there is a simpler method for writing a stateless HOL kernel, which we adopt in \mosquito.
Constants can be represented as a compound type consisting of their name as well as their definition, rather than simply their name as in e.g. HOL Light.
A constant $\mathtt{C}$ is now only equal to a constant $\mathtt{C'}$ if they share the same name \emph{and} definition.
Defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$ now no longer entails that a deduction of $\mathtt{0 = 1}$ is possible, and consistency is therefore retained without appeal to explicit state passing.
\paragraph{Why develop another HOL?}
\mosquito was originally conceived as a kernel suitable for machine formalisation.
To a certain extent, that prototype got out of hand, and we started developing machinery atop the kernel, such as tactics, tacticals, and proof state representations, that surpassed our original intentions.
Writing proof assistants is fun.

The influence of this original idea persists, however, and \mosquito is purposefully written in a style which we think is amenable to machine-assisted proof of correctness.
The \mosquito kernel itself is stateless, as we have noted.
Exceptions, pervasive in other HOLs for handling errors, are completely avoided in favour of a monadic programming style.
We do not use mutable data structures.
Haskell's strict regimen of noting effects in types prevents us from arbitrarily mixing effectful and pure code.
Partiality is also kept to an absolute minimum, and to the best of our knowledge is present in only one place within the \mosquito code base.
Even here, if we chose to adopt more advanced Haskell type-level extensions, we could eliminate this partiality.

We chose to implement `vanilla HOL' rather than a more expressive logic.
In these matters, we believe a certain conservatism is to be preferred, as HOL is well understood, widely implemented, relatively simple but expressive enough to capture a large amount of mathematics and computer science.
\paragraph{Related work}
Austin and Alexander have previously implemented `HaskHOL', the kernel of a stateless HOL with quantified types \emph{a la} System F in Haskell~\cite{austin:stateless:2013}.
Wiedijk implemented a stateless version of HOL Light and did empirical tests on the performance differences between the two systems~\cite{wiedijk:stateless:2011}.
To the best of our knowledge, \mosquito is the first implementation of vanilla HOL in Haskell.

\section{Logic}
\label{sect.logic}

\section{Tactics and the proof state}
\label{sect.tactics.proof.state}

\subsection{The proof state}
\label{subsect.proof.state}

\mosquito supports both \emph{forward} and \emph{backward} proof styles.
Forward proof is supported via direct construction of elements of the $\mathtt{Theorem}$ data type, using the basic axioms of higher-order logic implemented in the \mosquito kernel.
Backwards proof is supported via \emph{tactics}, and a notion of \emph{proof state} which captures the possibly incomplete derivation of some conjecture.

Unlike other proof assistants in the HOL family---e.g. HOL Light---a concrete tree is used to represent the current incomplete derivation, rather than a stack of goals:
\begin{lstlisting}
data ProofTree
  = Hole Tag [Theorem] Term
  | Leaf Theorem
  | Node Justification [ProofTree]
\end{lstlisting}
Here, we use the $\mathtt{Hole}$ constructor to represent goals left to prove.
Goals are `tagged' as being either \emph{selected} or \emph{unselected}.
Each $\mathtt{Hole}$ has a list of assumptions, represented as elements of the $\mathtt{Theorem}$ data type, plus the goal term to be proved.

We use the $\mathtt{Leaf}$ constructor to represent goals that have been closed outright with the use of a theorem.
We use the $\mathtt{Node}$ constructor to represent goals that have been \emph{refined} into simpler subgoals using a tactic.
A $\mathtt{Node}$ is equipped with a $\mathtt{Justification}$ function, of type:
\begin{lstlisting}
type Justification = [Theorem] $\rightarrow$ Inference Theorem
\end{lstlisting}
Intuitively, a $\mathtt{Justification}$

\begin{lstlisting}
data ProofState = ProofState { goal :: Term, tree :: ProofTree, ... }
\end{lstlisting}

\begin{lstlisting}
conjecture :: String $\rightarrow$ Term $\rightarrow$ Inference ProofState
conjecture = ...
\end{lstlisting}

\begin{lstlisting}
qed :: ProofState $\rightarrow$ Inference Theorem
qed = ...
\end{lstlisting}

\begin{lstlisting}
apply :: PreTactic $\rightarrow$ Tactic
apply = ...
\end{lstlisting}

\subsection{Tactics, tacticals and stackticals}
\label{subsect.tactics.tacticals.modifying.proof.state}

\mosquito tactics are developed in two stages.
A $\mathtt{PreTactic}$ is a function of type:
\begin{lstlisting}
type PreTactic = [Theorem] $\rightarrow$ Term $\rightarrow$ Inference ProofStep
\end{lstlisting}
Intuitively, a $\mathtt{PreTactic}$ can be thought of as a local update on a derivation tree, applying only at $\mathtt{Hole}$s.

\begin{lstlisting}
data ProofStep
  = Refine Justification [ProofStep]
  | Open [Theorem] Term
\end{lstlisting}

\begin{lstlisting}
type Tactic = ProofState $\rightarrow$ Inference ProofState
\end{lstlisting}

\begin{lstlisting}
selectPTac :: ([Theorem] $\rightarrow$ Term $\rightarrow$ Bool) -> Tactic
selectPTac = ...
\end{lstlisting}

\begin{lstlisting}
selectITac :: (Int $\rightarrow$ Bool) $\rightarrow$ Tactic
selectITac = ...
\end{lstlisting}

\begin{lstlisting}
($\oplus$) :: Tactic $\rightarrow$ Tactic $\rightarrow$ Tactic
($\oplus$) l r state = inference (l state) (const $\circ$ r $\$$ state) return

repeat :: Tactic $\rightarrow$ Tactic
repeat tactic state = inference (tactic state) (const $\circ$ return $\$$ state) (repeat tactic)
\end{lstlisting}

\begin{lstlisting}
($\rightarrowtail$) :: Monad m $\Rightarrow$ ($\alpha$ $\rightarrow$ m $\beta$) $\rightarrow$ ($\beta$ $\rightarrow$ m $\gamma$) $\rightarrow$ $\alpha$ $\rightarrow$ m $\gamma$
($\rightarrowtail$) = ...
\end{lstlisting}

\begin{lstlisting}
autoBase :: Tactic
autoBase = repeat $\$$ alphaTac $\oplus$ autoEtaTac $\oplus$ autoBetaTac
  where
    autoBetaTac :: Tactic
    autoBetaTac = betaTac $\oplus$ (symmetryTac $\rightarrowtail$ betaTac)

    autoEtaTac :: Tactic
    autoEtaTac = etaTac $\oplus$ (symmetryTac $\rightarrowtail$ etaTac)
\end{lstlisting}

\section{Conclusions}
\label{sect.conclusions}

\bibliography{mulligan-mosquito-2013}

\end{document}