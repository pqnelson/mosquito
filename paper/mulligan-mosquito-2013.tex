\let\accentvec\vec
  \documentclass{llncs}
    \let\spvec\vec
    \let\vec\accentvec
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled]{beramono}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{microtype}
\usepackage{prooftree}
\usepackage{tgpagella}
\usepackage{xspace}

\author{Dominic P. Mulligan}
\title{Mosquito: an implementation of higher-order logic}
%\subtitle{(Rough diamond)}
\titlerunning{Mosquito}
\institute{Computer Laboratory, University of Cambridge}

\newcommand{\act}{\cdot}
\newcommand{\aeq}{=_\alpha}
\newcommand{\deffont}[1]{\textbf{#1}}
\newcommand{\ent}{\vdash}
\newcommand{\lam}[1]{\lambda{#1}.}
\newcommand{\mosquito}{Mosquito\xspace}
\newcommand{\rulefont}[1]{\ensuremath{(\mathbf{#1})}}
\newcommand{\tf}[1]{\mathsf{#1}}

\bibliographystyle{alpha}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=haskell,                 % the language of the code
  mathescape=true,
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  belowskip=-1.125\baselineskip
}

\begin{document}

\maketitle

\begin{abstract}
We present \mosquito, a stateless, pure, largely total LCF-style implementation of higher-order logic, using Haskell as a metalanguage.
We discuss details of the logic implemented, kernel design and novel proof state and tactic representations.
\end{abstract}

\section{Introduction}
\mosquito is an LCF-style implementation of higher-order logic (HOL) using Haskell as its metalanguage.
The system is under active development.
Some simple proofs, both forward and backward, have been carried out in the system: Boolean, pair and set theories are under construction, for instance.
\mosquito may be obtained anonymously from a public Mercurial respository.\footnote{\url{https://bitbucket.org/MosquitoProofAssistant/mosquito}}

Existing LCF-style implementations written in ML such as HOL4~\cite{gordon:introduction:1993}, HOL Light~\cite{harrison:hol:2009} and Isabelle~\cite{wenzel:isabelle:2008} intrinsically rely on state within their kernels.
When extending the logic with definition of a new constant, care must be taken to ensure that constants are not defined twice, lest, as pointed out by Wiedijk~\cite{wiedijk:stateless:2011}, we make our system inconsistent by defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$, then deducing $\vdash \mathtt{0 = 1}$ by transitivity and symmetry of equality.
This, in the systems mentioned above, is managed by a stateful kernel wherein a mutable database of existing constant names is maintained and queried prior to admitting a new constant definition.

Prevailing Haskell programming style tends to avoid the use of imperative update and maintenance of implicit state, whenever possible.
Rather, explicit state tends to be passed around, with a monadic style of programming adopted to assuage the pain of explicit state passing.
However, a na\"ive translation of an existing LCF-style kernel to Haskell using explicit state passing would be prone to inconsistencies without careful management of the many versions of the immutable state object floating around the system, as well as exposing a cumbersome \textsc{api} to the programmer.
%A na\"ive translation would also radically change the \textsc{api} of the kernel presented to the programmer, making it cumbersome to use in comparison to the kernels of existing systems.

As Wiedijk noted, there is a simple method for writing a stateless HOL kernel, empirically only entailing a moderate slow down in the system when compared to those implemented using state, whilst retaining the elegance of the original stateful design, which we adopt in \mosquito.
Constants can be represented as a compound type consisting of their name as well as their definition, rather than simply their name as in e.g. HOL Light.
A constant $\mathtt{C}$ is now only equal to a constant $\mathtt{C'}$ if they share the same name \emph{and} definition.
Defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$ is now `safe', as a deduction of $\vdash \mathtt{0 = 1}$ is no longer possible.
A similar scheme is used to tag type formers and the \emph{abstraction} and \emph{representation} constants for new types---bearing witness to a require bijection with a subset of an existing type---with their defining theorems.
Consistency is retained.

\paragraph{Why develop another proof assistant?  Why choose HOL?}
\mosquito was conceived as a kernel prototype suitable for machine formalisation.
By controlling state and adopting a monadic programming style, disavowing the use of exceptions to signal failure, and maintaining totality as far as possible, it is hoped the resulting system is easier to formalise in a proof assistant than systems such as HOL4 and HOL Light.
To an extent, that initial prototype got out of hand, and we started developing machinery atop the kernel, such as tactics and proof state representations, as well as conducting proofs of simple conjectures in the system.
The influence of this original idea persists, and \mosquito is purposefully written in a style which we think is amenable to a machine-checked proof of correctness.

HOL is a well understood and a widely implemented logic.
It is relatively simple, with the core logic being described fully in a handful of inference rules, yet nevertheless has a proven track record in being able to capture a wide swathe of mathematics and computer science.
Further, by implementing HOL, one may leverage existing expertise and tools---for example, importing and exporting proofs to-and-from other implementations of HOL via OpenTheory~\cite{hurd:opentheory:2011}, or even making use of automated proof tools already implemented and tested in e.g. Isabelle/HOL to close proof obligations in \mosquito~\cite{kumar:standalone:2012}.

Mosquito fills a niche: it's an implementation of vanilla HOL---potentially maintaining interoptability with existing HOLs via OpenTheory---using Haskell, not an ML dialect, as its metalanguage.

\paragraph{Related work}
Multiple implementations of HOLs and similar systems exist, though two existing systems are particularly closely related.
Wiedijk's Stateless HOL~\cite{wiedijk:stateless:2011} is a modification of HOL Light with a stateless kernel.
Austin and Alexander's HaskHOL~\cite{austin:stateless:2013} is an implementation of HOL extended with System-F style polymorphism also using Haskell as a metalanguage.

\begin{figure}
\begin{gather*}
\begin{prooftree}
(t \aeq u)
\justifies
\{\} \vdash t = u
\using\rulefont{alpha}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash u = t
\using\rulefont{symm}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash u = v
\justifies
\Gamma \cup \Delta \vdash t = v
\using\rulefont{trans}
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
(t : \mathtt{Bool})
\justifies
\{ t \} \vdash t
\using\rulefont{assm}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t \quad \Delta \vdash u
\justifies
(\Gamma - u) \cup (\Delta - t) \vdash t = u
\using\rulefont{asym}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \ent t = u \quad \Delta \ent u
\justifies
\Gamma \cup \Delta \ent t
\using\rulefont{eqmp}
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash \lam{a{:}\phi}t = \lam{a{:}\phi}u
\using\rulefont{abs}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash v = w
\justifies
\Gamma \cup \Delta \vdash t \cdot v = u \cdot w
\using\rulefont{comb}
\end{prooftree}
\quad
\begin{prooftree}
\phantom{h}
\justifies
\{\} \vdash \lam{a{:}\phi}t \cdot u = t[a/u]
\using\rulefont{beta}
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
(a \not\in fv(t))
\justifies
\{\} \vdash \lam{a{:}\phi}(t \cdot a) = t
\using\rulefont{eta}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\vec{b}/\vec{u}] \vdash t[\vec{b}/\vec{u}]
\using\rulefont{inst}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\vec{\alpha}/\vec{\phi}] \vdash t[\vec{\alpha}/\vec{\phi}]
\using\rulefont{tyinst}
\end{prooftree}
\end{gather*}
\caption{Inference rules for \mosquito's logic}
\label{fig.rules}
\end{figure}

\section{\mosquito's logic}
\mosquito implements a similar higher-order logic to the HOL Light system.
Terms $t$, $u$, and so on, are terms of the simply-typed $\lambda$-calculus extended with constants.
The full derivation rules for the core logic are presented in Figure~\ref{fig.rules}.
Here, $\Gamma$ and $\Delta$ range over arbitrary contexts, $\{\}$ is the empty context, $fv(t)$ corresponds to the usual set of free variables of a term, $t[\vec{\alpha}/\vec{\phi}]$ is a parallel substitution replacing type variables in a term, and $\Gamma[\vec{\alpha}/\vec{\phi}]$ is the pointwise parallel type variable substitution operating on a context (similarly for parallel capture-avoiding substitutions $t[\vec{b}/\vec{u}]$ of term variables).

\mosquito follows the well-worn LCF design philosophy.
The kernel exposes several abstract types: $\mathtt{Term}$, $\mathtt{Type}$ and $\mathtt{Theorem}$.
Modulo bugs in the design of the Haskell language, or within implementation of GHC, the only way to construct a non-bottom inhabitant of $\mathtt{Theorem}$ is via appeal to the implementation of the rules in Figure~\ref{fig.rules}.

The kernel exports two primitive \emph{type formers}: $\mathtt{Bool}$, the Booleans, and $- \Rightarrow -$, the function space arrow.
Each type former is equipped with an \emph{arity}, a natural number detailing the number of types one must supply to the former to construct a new type.
Call a fully-applied type former a \emph{type}.
The primitive type \texttt{Bool} has arity 0, whilst the primitive type former $- \Rightarrow -$ has arity 2.
The \textsc{api} exposed in the kernel ensures one may only construct `arity correct' types.

Similarly, the kernel exports a single primitive constant, $- = -$, the equality constant, of type $\alpha \Rightarrow \alpha \Rightarrow \mathtt{Bool}$.
Equalities, $t = u$ in Figure~\ref{fig.rules}, are therefore implemented merely as applications $(= t) u$ with syntactic sugar sprinkled atop.
Terms within the kernel are fully type annotated and only type-correct terms may be constructed.
Figure~\ref{fig.rules} should be interpreted as including a series of hidden typing constraints.
Under this scheme, the side condition stating $t$ must be a \emph{formula}---a term of type $\mathtt{Bool}$---in rule \rulefont{assm} makes sense, and the construction of a term $t = u$ necessarily implies that the terms $t$ and $u$ possess the same type.

The \mosquito kernel implements slightly stronger inference rules than the HOL Light kernel.
Rule \rulefont{alpha} bakes $\alpha$-equivalence, implemented using `nominal'-style swappings, into \mosquito's reflexivity rule.
In HOL Light a weakened form of \rulefont{eta} is axiomatised outwith the kernel.
Similarly, a weakened form of \rulefont{beta} is implemented in the HOL Light kernel.
The strengthened versions of $\eta$- and $\beta$-equality are then supplied later, as derived rules.
We choose to implement the full versions of these rules directly in \mosquito's kernel.

\mosquito's core higher-order logic may be extended in three ways.
A new constant may be defined as equal to an existing term, modulo restrictions on the free (type-)variables of that term.
A new inhabited type may be defined in provable bijection with a subset of an existing type.
Lastly, a formula may be asserted freeform as an axiom.
As axioms are `dangerous' from a consistency point of view, \mosquito, indelibly marks any theorem obtained directly or indirectly from an axiom.

\section{Tactics and the proof state}
\label{sect.tactics.proof.state}

\mosquito supports forward proof by direct appeal to the kernel implementation of the primitive HOL rules and axioms in Figure~\ref{fig.rules}.
However, for more complex proofs, backward proof---gradually decomposing a goal into simpler subgoals---may be more amenable.
\mosquito supports backward proof (as well as a mixture of the two) via \emph{tactics} operating on a \emph{proof state}.

A \mosquito proof state consists of an explicit incomplete derivation tree---a rose tree with an additional constructor $\mathtt{Hole}$ corresponding to a proof obligation, or `something to prove'---and some metadata.
Each $\mathtt{Hole}$ has a local list of assumptions as well as the goal to prove at that hole.
Holes are either selected or unselected.
Each branch in the incomplete derivation tree is annotated with a \emph{justification} a function used to collapse a complete derivation tree, replaying the proof in a forward direction once completed, into a $\mathtt{Theorem}$.
The \mosquito proof state \textsc{api} exposes three key functions, where $\mathtt{Inference}$ is a (monadic) type constructor used to signal failure:
\begin{lstlisting}
mkConjecture :: Term $\rightarrow$ Inference ProofState
qed :: ProofState $\rightarrow$ Inference Theorem
act :: ProofState $\rightarrow$ Tactic $\rightarrow$ Inference ProofState
\end{lstlisting}

A new proof state is constructed using $\mathtt{mkConjecture}$.
This takes as input a formula and creates an incomplete derivation tree consisting of a selected hole with no assumptions and the formula as the goal to prove, failing if the input term does not have $\mathtt{Bool}$ type.
A proof state is transformed into a $\mathtt{Theorem}$ using $\mathtt{qed}$, failing if the justification functions annotating the enclosed derivation tree do not correctly replay the proof in a forward direction via the kernel, produces a $\mathtt{Theorem}$ that fails to match the original conjecture prompting the creation of the tree, or if the derivation tree is still incomplete.

Proof states are transformed using the $\mathtt{act}$ function, which applies a tactic to a proof state, obtaining a new proof state.
Intuitively, tactics are applied to every selected goal at once.
Zero or many goals may be selected at one time.
A tactic must succeed at \emph{every} selected goal for $\mathtt{act}$ itself to succeed.
Should a tactic succeed at a goal it is transformed into a branch in the derivation tree with selected holes corresponding to the new subgoals as children.
The required justification function is supplied by the tactic.
This style of tactic application is similar in spirit to a style employed in Matita~\cite{asperti:matita:2011} and facilitates the sharing of chunks of tactic driven proof across multiple similar goals.

In other HOLs tactics are pieced together via tactic-valued functionals called tacticals.
In contrast, \mosquito embeds the abstract syntax tree of a \emph{proof description language} explicitly as an algebraic data type:
\begin{lstlisting}
data Tactic
  = Apply PreTactic | ($\rightarrowtail$) Tactic Tactic | Id | FailWith String
  | Try Tactic | ($\oplus$) Tactic Tactic | Repeat Tactic
\end{lstlisting}

The semantics of proof descriptions is dictated by the $\mathtt{act}$ function above which uses a tactic to transform proof states.

For every proof state $\mathtt{p}$, a call to $\mathtt{act\ p\ (FailWith\ err)}$ will result in failure, with $\mathtt{err}$ as a diagnostic error message, whilst a call to $\mathtt{act\ p\ Id}$ will always successfully return $\mathtt{p}$.
A call to $\mathtt{act\ p\ (Try\ t)}$ first tries to apply $\mathtt{t}$, succeeding if this succeeds with the new proof state, or succeeding with the old proof state if this fails.
Repetition of tactic application is handled with $\mathtt{Repeat\ t}$, which attempts to apply $\mathtt{t}$ at least once to a proof state.
Sequencing and choice are handled via $(\rightarrowtail)$ and $(\oplus)$, respectively.
The call $\mathtt{act\ p\ (t \rightarrowtail t')}$ will first try to transform $\mathtt{p}$ with $\mathtt{t}$.
If that succeeds, then the resulting state will be transformed by $\mathtt{t'}$, otherwise the call results in failure.
Similarly, $\mathtt{act\ p\ (t \oplus t')}$ attempts $\mathtt{t}$, returning success if that transformation succeeded, otherwise attempts $\mathtt{t'}$.

$\mathtt{Apply}$ is perhaps the most interesting constructor of the $\mathtt{Tactic}$ data type, lifting a \emph{pretactic} into a tactic.
Intuitively, a pretactic is a function that edits a selected hole in the derivation tree.
A pretactic is supplied with the assumptions and goal to prove at that hole, and may either fail with an error at that hole, in which case it is not applicable, or succeed, returning a list of new subgoals which are spliced into the derivation tree as new holes coupled with a justification function which reverses the pretactic's work.
Pretactics are entirely `local'---they are not supplied with a global view of the entire derivation tree under construction.
For example, $\mathtt{alphaPreTactic}$ examines the goal at a given hole, decides whether the goal is an equality, tests whether both sides of the equality are $\alpha$-equivalent, and if so returns an empty list of new goals coupled with a justification function that makes use of the implementation of \rulefont{alpha} from Figure~\ref{fig.rules}.

The $\mathtt{Tactic}$ embedding may be minimalist, but more complex tactics\footnote{We abuse language and refer to any $\mathtt{Tactic}$-valued Haskell function as a tactic.} may be written over this type.
For instance, the tactic $\mathtt{repeatN}$ repeatedly applies a tactic $\mathtt{m}$ times to a given proof state:
\begin{lstlisting}
repeatN :: Int $\rightarrow$ Tactic $\rightarrow$ Tactic
repeatN 0 tactic = Id
repeatN m tactic = tactic $\rightarrowtail$ repeatN (m - 1) tactic
\end{lstlisting}

More complex tactics `compile' down into more primitive tactics.
This sits in contrast to other systems where complex tactics are created by combining together primitive tactics with tacticals.

One advantage of treating \mosquito tactics as data is that they may be manipulated as such.
In particular, the $\mathtt{act}$ function induces an equational theory on $\mathtt{Tactic}$: say that two tactics $\mathtt{t}$ and $\mathtt{t'}$ are equivalent if for any $\mathtt{p}$ their resulting transformation of $\mathtt{p}$ using $\mathtt{act}$ is identical.
Under this scheme, one would expect $\mathtt{Id \rightarrowtail t}$ and $\mathtt{t}$ to be equivalent, as well as $\mathtt{Repeat\ (FailWith\ err)}$ and $\mathtt{FailWith\ err}$, along with several other similar equalities.
As such, we may write a tactic $\mathtt{optimise}$ of type $\mathtt{Tactic \rightarrow Tactic}$ which rewrites its input according to the equational theory induced by $\mathtt{act}$ and produces an `optimised' output.

Several other tactics cause $\mathtt{act}$ to diverge on any proof state.
For instance, the tactic $\mathtt{Repeat\ Id}$ will cause $\mathtt{act}$ to diverge, as $\mathtt{Id}$ always succeeds leaving the proof state unchanged.
We may write a tactic $\mathtt{replaceBottoms}$ which rewrites its input, removing sources of divergence, and replacing them with a (converging) occurence of $\mathtt{FailWith\ err}$ where $\mathtt{err}$ contains some diagnostic information useful in tracking down the source of the divergence.

Similarly, one may write a `tactic debugger', $\mathtt{debug}$, of type
\begin{displaymath}
\mathtt{ProofState \rightarrow Tactic \rightarrow Inference\ (ProofState,\ Maybe\ Tactic)}
\end{displaymath}
a function that small-steps through the transformation of a proof state under the action of a tactic.
For example, $\mathtt{debug}$ when called with the tactic $\mathtt{t \rightarrowtail t'}$ and proof state $\mathtt{p}$ as input first applies $\mathtt{t}$ to $\mathtt{p}$.
If this succeeds, it successfully returns the new proof state paired with $\mathtt{t'}$, otherwise failing.

\section{Conclusions}
\label{sect.conclusions}

\mosquito is a stateless, pure, largely total implementation of higher-order logic in Haskell.

\paragraph{Further work}
Mosquito was initially conceived as a prototype kernel written in a style thought amenable for machine checked proof of correctness.
We would like to see that proof of correctness carried out in the future: for both the kernel

\bibliography{mulligan-mosquito-2013}

\end{document}