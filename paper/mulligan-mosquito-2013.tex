\let\accentvec\vec
  \documentclass{llncs}
    \let\spvec\vec
    \let\vec\accentvec
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled]{beramono}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{microtype}
\usepackage{prooftree}
\usepackage{tgpagella}
\usepackage{xspace}

\author{Dominic P. Mulligan}
\title{Mosquito: an implementation of higher-order logic}
\subtitle{(Rough diamond)}
\titlerunning{Mosquito}
\institute{Computer Laboratory, University of Cambridge}

\newcommand{\act}{\cdot}
\newcommand{\aeq}{=_\alpha}
\newcommand{\deffont}[1]{\textbf{#1}}
\newcommand{\ent}{\vdash}
\newcommand{\lam}[1]{\lambda{#1}.}
\newcommand{\mosquito}{Mosquito\xspace}
\newcommand{\rulefont}[1]{\ensuremath{(\mathbf{#1})}}
\newcommand{\tf}[1]{\mathsf{#1}}

\bibliographystyle{alpha}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=haskell,                 % the language of the code
  mathescape=true,
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  belowskip=-1.125\baselineskip
}

\begin{document}

\maketitle

\begin{abstract}
We present \mosquito, a stateless, pure, largely total LCF-style implementation of higher-order logic, using Haskell as a metalanguage.
We discuss details of the logic implemented, kernel design and novel proof state and tactic representations.
\end{abstract}

\section{Introduction}
\mosquito is an LCF-style implementation of higher-order logic (HOL) using Haskell as its metalanguage.
The system is under active development.
Some simple proofs, both forward and backward, have been carried out in the system: Boolean, pair and set theories are under construction, for instance.
\mosquito may be obtained anonymously from a public Mercurial respository.\footnote{\url{https://bitbucket.org/MosquitoProofAssistant/mosquito}}

Existing LCF-style implementations written in ML such as HOL4~\cite{gordon:introduction:1993}, HOL Light~\cite{harrison:hol:2009} and Isabelle~\cite{wenzel:isabelle:2008} intrinsically rely on state within their kernels.
When extending the logic with definition of a new constant, care must be taken to ensure that constants are not defined twice, lest, as pointed out by Wiedijk~\cite{wiedijk:stateless:2011}, we make our system inconsistent by defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$, then deducing $\vdash \mathtt{0 = 1}$ by transitivity and symmetry of equality.
This, in the systems mentioned above, is managed by a stateful kernel wherein a mutable database of existing constant names is maintained.
The redefinition of existing constants is therefore prevented by querying this database prior to admitting a new constant definition.

Prevailing Haskell programming style tends to avoid the use of imperative update and maintenance of implicit state, whenever possible.
Rather, explicit state tends to be passed around, with a monadic style of programming adopted to assuage the pain of explicit state passing.
However, a na\"ive translation of an existing LCF-style kernel to Haskell using explicit state passing would be prone to inconsistencies without careful management of the many versions of the immutable state object floating around the system.
%A na\"ive translation would also radically change the \textsc{api} of the kernel presented to the programmer, making it cumbersome to use in comparison to the kernels of existing systems.

As Wiedijk noted, there is a simple method for writing a stateless HOL kernel, empirically only entailing a moderate slow down in the system when compared to those implemented using state, which we adopt in \mosquito.
Constants can be represented as a compound type consisting of their name as well as their definition, rather than simply their name as in e.g. HOL Light.
A constant $\mathtt{C}$ is now only equal to a constant $\mathtt{C'}$ if they share the same name \emph{and} definition.
Defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$ is now `safe', as a deduction of $\vdash \mathtt{0 = 1}$ is no longer possible.
Consistency is therefore retained.

\paragraph{Why develop another proof assistant?}
\mosquito was originally conceived as a prototype of a kernel suitable for machine formalisation.
By controlling state and adopting a monadic programming style, disavowing the use of exceptions to signal failure, and maintaining totality as far as possible, it was hoped the resulting system would be easier to formalise in a proof assistant directly than systems such as HOL4 and HOL Light.
To a certain extent, that initial prototype got out of hand, and we started developing machinery atop the kernel, such as tactics and proof state representations, as well as conducting proofs of simple conjectures in the system---using Haskell as a metalanguage
However, the influence of this original idea persists, and \mosquito is purposefully written in a style which we think is amenable to a machine-assisted proof of correctness.

\paragraph{Why choose HOL?}
HOL is a well understood and a widely implemented logic.
It is relatively simple, with the core logic being described fully in a handful of inference rules, yet nevertheless has a proven track record in being able to capture a wide swathe of mathematics and computer science.
Further, by implementing HOL, one may leverage existing expertise and tools---for example, importing and exporting proofs to-and-from other implementations of HOL via OpenTheory~\cite{hurd:opentheory:2011}, or even making use of automated proof tools already implemented and tested in e.g. Isabelle/HOL to close proof obligations in \mosquito~\cite{kumar:standalone:2012}.

\paragraph{Related work}
Multiple implementations of HOLs and `HOL like' systems exist, though two existing systems are particularly closely related.
Wiedijk's Stateless HOL~\cite{wiedijk:stateless:2011} is a modified implementation of HOL Light with a stateless kernel.
Austin and Alexander's HaskHOL~\cite{austin:stateless:2013} is an implementation of HOL extended with System-F style polymorphism implemented in Haskell.

\begin{figure}
\begin{gather*}
\begin{prooftree}
(t \aeq u)
\justifies
\{\} \vdash t = u
\using\rulefont{alpha}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash u = t
\using\rulefont{symm}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash u = v
\justifies
\Gamma \cup \Delta \vdash t = v
\using\rulefont{trans}
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
(t : \mathtt{Bool})
\justifies
\{ t \} \vdash t
\using\rulefont{assm}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t \quad \Delta \vdash u
\justifies
(\Gamma - u) \cup (\Delta - t) \vdash t = u
\using\rulefont{asym}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \ent t = u \quad \Delta \ent u
\justifies
\Gamma \cup \Delta \ent t
\using\rulefont{eqmp}
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash \lam{a{:}\phi}t = \lam{a{:}\phi}u
\using\rulefont{abs}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash v = w
\justifies
\Gamma \cup \Delta \vdash t \cdot v = u \cdot w
\using\rulefont{comb}
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
\phantom{h}
\justifies
\{\} \vdash \lam{a{:}\phi}t \cdot u = t[a/u]
\using\rulefont{beta}
\end{prooftree}
\quad
\begin{prooftree}
(a \not\in fv(t))
\justifies
\{\} \vdash \lam{a{:}\phi}(t \cdot a) = t
\using\rulefont{eta}
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\vec{b}/\vec{u}] \vdash t[\vec{b}/\vec{u}]
\using\rulefont{inst}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\vec{\alpha}/\vec{\phi}] \vdash t[\vec{\alpha}/\vec{\phi}]
\using\rulefont{tyinst}
\end{prooftree}
\end{gather*}
\caption{Inference rules for \mosquito's logic}
\label{fig.rules}
\end{figure}

\section{\mosquito's logic}
\mosquito implements a similar higher-order logic to the HOL Light system.
Terms $t$, $u$, and so on, are terms of the simply-typed $\lambda$-calculus extended with constants.
The full derivation rules for the core logic are presented in Figure~\ref{fig.rules}.
Here, $\Gamma$ and $\Delta$ range over arbitrary contexts, $\{\}$ is the empty context, $fv(t)$ corresponds to the usual set of free variables of a term, $t[\vec{\alpha}/\vec{\phi}]$ is a parallel substitution replacing type variables in a term, and $\Gamma[\vec{\alpha}/\vec{\phi}]$ is the pointwise parallel type variable substitution operating on a context (similarly for parallel capture-avoiding substitutions $t[\vec{b}/\vec{u}]$ of term variables).

To maintain consistency, \mosquito follows the LCF design philosophy.
The kernel exposes several abstract types: $\mathtt{Term}$, $\mathtt{Type}$ and $\mathtt{Theorem}$.
Modulo bugs in the design of the Haskell language, or within implementation of GHC, the only way to construct a non-bottom inhabitant of $\mathtt{Theorem}$ is via appeal to the implementation of the rules in Figure~\ref{fig.rules}.

In particular, the kernel exports two primitive \emph{type formers}: $\mathtt{Bool}$, the Booleans, and $- \Rightarrow -$, the function space arrow.
Each type former is equipped with an \emph{arity}, a natural number detailing the number of other types one must supply to the former to construct a new type---0 in the case of \texttt{Bool} and 2 in the case of $- \Rightarrow -$.
Call a fully-applied type former a \emph{type} (so $\mathtt{Bool}$ is both a type former and a type).
A `term builder' \textsc{api} is exposed in the kernel which ensures one may only construct `arity correct' types.

Similarly, the kernel exports a single primitive constant, $- = -$, the equality constant, of type $\alpha \Rightarrow \alpha \Rightarrow \mathtt{Bool}$.
Equalities, $t = u$ in Figure~\ref{fig.rules}, are therefore implemented merely as applications $(= t) u$ with some syntactic sugar sprinkled on top for ease of digestion.
Terms within the kernel are fully type annotated and only type-correct terms may be constructed.
The rules above should therefore be read as including a series of hidden typing constraints.
Under this scheme, the side condition stating $t$ must be a \emph{formula}---a term of type $\mathtt{Bool}$---in rule \rulefont{assm} makes sense, and the construction of a term $t = u$ necessarily implies that the terms $t$ and $u$ possess the same type.

The \mosquito kernel implements slightly stronger inference rules than the HOL Light kernel.
Rule \rulefont{alpha} bakes $\alpha$-equivalence into \mosquito's reflexivity rule.
In HOL Light a weakened form of \rulefont{eta} is axiomatised outwith the kernel, with the full rule being derived later.
We choose instead to implement the full $\eta$-equivalence rule within the kernel itself.
Similarly, HOL Light's corresponding \rulefont{beta} rule is a weakened form of the full $\beta$-equivalence rule that we implement in \mosquito, with the full rule derived later.
Again, we choose to implement the full rule directly in \mosquito's kernel.

\mosquito's core higher-order logic may be extended in three ways.
A new constant may be defined as equal to an existing term.
Various standard side-conditions on this definitional mechanism maintain consistency of the logic.
A new type may be defined.
This requires the user submit proof that the new type is in bijection with a subset of an existing type, and that the new type is inhabited.
Again, these side-conditions are standard amongst HOL implementations, modulo minor differences.
Lastly, a formula may be asserted freeform as an axiom.
As axioms are dangerous from a consistency point of view, \mosquito, indelibly `marks' any theorem obtained either directly as an admitted axiom, or indirectly from a derivation that mentions an axiom.

\section{Tactics and the proof state}
\label{sect.tactics.proof.state}

Mosquito supports forwards-directed proof directly via application of the primitive HOL rules and axioms implemented in the Mosquito kernel.
Backwards-directed proof, more amenable for proving complex conjectures, is supported through the use of \emph{tactics} operating on a \emph{proof state}.

A Mosquito proof state is a wrapper around an \emph{incomplete derivation}, an element of the Haskell type:
\begin{lstlisting}
data IncompleteDerivation
  = Hole Selection [Theorem] Term
  | Branch Justification [IncompleteDerivation]
\end{lstlisting}
An incomplete derivation is a derivation tree with holes.
Intuitively, holes (as represented by the Haskell constructor $\mathtt{Hole}$) correspond to parts of a derivation tree yet to be filled in, or rather, goals left to prove in pursuit of a complete proof of a conjecture.
Holes are annotated with a list of assumptions local to that goal as well as the goal term itself.

Branches (as represented by the Haskell constructor $\mathtt{Branch}$) within a derivation tree are annotated with a \emph{justification}, a function of type $\mathtt{[Theorem]} \rightarrow \mathtt{Theorem}$.
A justification function is used to collapse a complete derivation tree into an element of type $\mathtt{Theorem}$ at the end of the proof---a forward replay of a backward proof.
Branches are equipped with a list of subtrees.
Intuitively, branches correspond to the backwards application of a proof rule or theorem.
Under this scheme, a branch with an empty list of subtrees denotes a closed goal---the application of an axiom, or the closure of a goal with a previously proved theorem, say.

Mosquito goals may be \emph{selected} or \emph{unselected}.
Multiple goals may be selected concurrently, or none at all.
Backwards proof in Mosquito is progressed by attempting to apply a tactic to every selected goal in an incomplete derivation concurrently.

\section{Conclusions and future work}
\label{sect.conclusions}

\bibliography{mulligan-mosquito-2013}

\end{document}