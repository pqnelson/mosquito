\documentclass{llncs}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled]{beramono}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{microtype}
\usepackage{prooftree}
\usepackage{tgpagella}
\usepackage{xspace}

\author{Dominic P. Mulligan}
\title{Mosquito: an implementation of higher-order logic}
\subtitle{(Rough diamond)}
\titlerunning{Mosquito}
\institute{Computer Laboratory, University of Cambridge}

\newcommand{\act}{\cdot}
\newcommand{\aeq}{=_\alpha}
\newcommand{\deffont}[1]{\textbf{#1}}
\newcommand{\ent}{\vdash}
\newcommand{\lam}[1]{\lambda{#1}.}
\newcommand{\mosquito}{Mosquito\xspace}
\newcommand{\rulefont}[1]{\ensuremath{(\mathbf{#1})}}
\newcommand{\tf}[1]{\mathsf{#1}}

\bibliographystyle{alpha}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=haskell,                 % the language of the code
  mathescape=true,
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  belowskip=-1.125\baselineskip
}

\begin{document}

\maketitle

\begin{abstract}
We present \mosquito, a stateless, pure, largely total LCF-style implementation of classical higher-order logic with choice in Haskell.
We discuss details of the logic implemented, the kernel design and proof state and tactic representations.
We present some simple tactic-guided backwards proofs of conjectures over the Booleans in the system.
\end{abstract}

\mosquito is an LCF-style implementation of higher-order logic (HOL) written in Haskell.
\mosquito's kernel consists of 1000 lines of commented Haskell.
Some infrastructure such as proof state representations and tactics are built atop this.
More is in development.
\paragraph{Writing a HOL in Haskell}
Existing LCF-style implementations written in ML such as HOL4~\cite{gordon:introduction:1993}, HOL Light~\cite{harrison:hol:2009} and Isabelle~\cite{wenzel:isabelle:2008} intrinsically rely on state within their kernels.
When extending the logic with new constant definitions, care must be taken to ensure that constants are not defined twice, lest, as pointed out by Wiedijk~\cite{wiedijk:stateless:2011}, we make our system inconsistent by defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$, then deducing $\mathtt{0 = 1}$ by transitivity and symmetry of equality.
This, in the systems mentioned above, is managed by a stateful kernel wherein a mutable database of existing constant names is maintained.
The redefinition of existing constants is therefore avoided.

Prevailing Haskell programming style tends to avoid the use of imperative update and maintenance of implicit state, whenever possible.
Rather, explicit state tends to be passed around, with a monadic style of programming adopted to assuage the pain of explicit state passing.
However, a na\"ive translation of an existing LCF-style kernel to Haskell using explicit state passing would be prone to inconsistencies without careful management of the many versions of the immutable state object floating around the system.
A na\"ive translation would also radically change the \textsc{api} of the kernel presented to the programmer, making it cumbersome to use in comparison to the kernels of existing systems.

As Wiedijk noted, there is a simpler method for writing a stateless HOL kernel, which we adopt in \mosquito.
Constants can be represented as a compound type consisting of their name as well as their definition, rather than simply their name as in e.g. HOL Light.
A constant $\mathtt{C}$ is now only equal to a constant $\mathtt{C'}$ if they share the same name \emph{and} definition.
Defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$ now no longer entails that a deduction of $\mathtt{0 = 1}$ is possible, and consistency is therefore retained without appeal to explicit state passing.

\begin{figure}
\begin{gather*}
\begin{prooftree}
(t \aeq u)
\justifies
\{\} \vdash t = u
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash u = t
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash u = v
\justifies
\Gamma \cup \Delta \vdash t = v
\end{prooftree}
\quad
\begin{prooftree}
(t : \mathtt{Bool})
\justifies
\{ t \} \vdash t
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t \quad \Delta \vdash u
\justifies
(\Gamma - u) \cup (\Delta - t) \vdash t = u
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash \lam{a{:}\phi}t = \lam{a{:}\phi}u
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash v = w
\justifies
\Gamma \cup \Delta \vdash t \cdot v = u \cdot w
\end{prooftree}
\quad
\begin{prooftree}
\phantom{h}
\justifies
\{\} \vdash \lam{a{:}\phi}t \cdot u = t[a := u]
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
(a \not\in fv(t))
\justifies
\{\} \vdash \lam{a{:}\phi}(t \cdot a) = t
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[b := u] \vdash t[b := u]
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\alpha := \phi] \vdash t[\alpha := \phi]
\end{prooftree}
\end{gather*}
\caption{Inference rules for \mosquito's logic}
\label{fig.rules}
\end{figure}

\paragraph{\mosquito's logic}
The basic axioms and rules of \mosquito's logic are described in Figure~\ref{fig.rules}.

\paragraph{Why develop another HOL?}
\mosquito was originally conceived as a kernel suitable for machine formalisation.
To a certain extent, that prototype got out of hand, and we started developing machinery atop the kernel, such as tactics, tacticals, and proof state representations, that surpassed our original intentions.
Writing proof assistants is fun.

The influence of this original idea persists, however, and \mosquito is purposefully written in a style which we think is amenable to machine-assisted proof of correctness.
The \mosquito kernel itself is stateless, as we have noted.
Exceptions, pervasive in other HOLs for handling errors, are completely avoided in favour of a monadic programming style.
We do not use mutable data structures.
Haskell's strict regimen of noting effects in types prevents us from arbitrarily mixing effectful and pure code.
Partiality is also kept to an absolute minimum, and to the best of our knowledge is present in only one place within the \mosquito code base.
Even here, if we chose to adopt more advanced Haskell type-level extensions, we could eliminate this partiality.

We chose to implement `vanilla HOL' rather than a more expressive logic.
In these matters, we believe a certain conservatism is to be preferred, as HOL is well understood, widely implemented, relatively simple but expressive enough to capture a large amount of mathematics and computer science.
\paragraph{Related work}
\begin{figure}
    \begin{tabular}{c||p{2.5cm}|c|c}
    ~            & Stateful Kernel                        & Stateless Kernel (ML) & Stateless Kernel (Haskell) \\ \hline\hline
    Vanilla HOL  & HOL Light, HOL 4, ProofPower, HOL Zero & Stateless HOL         & Mosquito                   \\ \hline
    Extended HOL & Isabelle, HOL2P, HOL$_\omega$          & ~                     & HaskHOL                    \\
    \end{tabular}
\caption{Related work}
\label{fig.related.work}
\end{figure}
Multiple implementations of HOLs and `HOL like' systems exist.
We survey related work in Figure~\ref{fig.related.work}.
Two existing systems are particularly closely related.
Wiedijk's Stateless HOL~\cite{wiedijk:stateless:2011} is a modified implementation of HOL Light with a stateless kernel.
Austin and Alexander's HaskHOL~\cite{austin:stateless:2013} is an implementation of HOL extended with System-F style polymorphism implemented in Haskell.

\section{Tactics and the proof state}
\label{sect.tactics.proof.state}

Mosquito supports forwards-directed proof directly via application of the primitive HOL rules and axioms implemented in the Mosquito kernel.
Backwards-directed proof, more amenable for proving complex conjectures, is supported through the use of \emph{tactics} operating on a \emph{proof state}.

A Mosquito proof state is a wrapper around an \emph{incomplete derivation}, an element of the Haskell type:
\begin{lstlisting}
data IncompleteDerivation
  = Hole Selection [Theorem] Term
  | Branch Justification [IncompleteDerivation]
\end{lstlisting}
An incomplete derivation is a derivation tree with holes.
Intuitively, holes (as represented by the Haskell constructor $\mathtt{Hole}$) correspond to parts of a derivation tree yet to be filled in, or rather, goals left to prove in pursuit of a complete proof of a conjecture.
Holes are annotated with a list of assumptions local to that goal as well as the goal term itself.

Branches (as represented by the Haskell constructor $\mathtt{Branch}$) within a derivation tree are annotated with a \emph{justification}, a function of type $\mathtt{[Theorem]} \rightarrow \mathtt{Theorem}$.
A justification function is used to collapse a complete derivation tree into an element of type $\mathtt{Theorem}$ at the end of the proof---a forward replay of a backward proof.
Branches are equipped with a list of subtrees.
Intuitively, branches correspond to the backwards application of a proof rule or theorem.
Under this scheme, a branch with an empty list of subtrees denotes a closed goal---the application of an axiom, or the closure of a goal with a previously proved theorem, say.

Mosquito goals may be \emph{selected} or \emph{unselected}.
Multiple goals may be selected concurrently, or none at all.
Backwards proof in Mosquito is progressed by attempting to apply a tactic to every selected goal in an incomplete derivation concurrently.

\section{Conclusions and future work}
\label{sect.conclusions}

\bibliography{mulligan-mosquito-2013}

\end{document}