\let\accentvec\vec
  \documentclass{llncs}
    \let\spvec\vec
    \let\vec\accentvec
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled]{beramono}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{mdwlist}
\usepackage{microtype}
\usepackage{prooftree}
\usepackage{tgpagella}
\usepackage{xspace}

\author{Dominic P. Mulligan\thanks{This work has benefitted from enlightening discussions with Thomas Tuerk and Ohad Kammar.}}
\title{Mosquito: an implementation of higher-order logic}
%\subtitle{(Rough diamond)}
\titlerunning{Mosquito}
\institute{Computer Laboratory, University of Cambridge}

\newcommand{\act}{\cdot}
\newcommand{\aeq}{=_\alpha}
\newcommand{\deffont}[1]{\textbf{#1}}
\newcommand{\ent}{\vdash}
\newcommand{\lam}[1]{\lambda{#1}.}
\newcommand{\mosquito}{Mosquito\xspace}
\newcommand{\rulefont}[1]{\ensuremath{(\mathbf{#1})}}
\newcommand{\tf}[1]{\mathsf{#1}}

\bibliographystyle{alpha}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=haskell,                 % the language of the code
  mathescape=true,
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  belowskip=-1.125\baselineskip
}

\begin{document}

\maketitle

\begin{abstract}
We present \mosquito: a stateless, pure, largely total LCF-style implementation of higher-order logic, using Haskell as a metalanguage.
We discuss details of the logic implemented, kernel design and novel proof state and tactic representations.
\end{abstract}

\mosquito is an LCF-style implementation of higher-order logic (HOL) using Haskell as its metalanguage.
The system is under active development.
Some simple proofs, both forward and backward, have been performed in the system: Boolean, pair and set theories are under construction, for instance.
\mosquito's source code may be obtained anonymously from a public Mercurial respository and is developed with the Glasgow Haskell Compiler (GHC)~7.6.2.\footnote{\url{https://bitbucket.org/MosquitoProofAssistant/mosquito}}

Existing LCF-style implementations written in ML such as HOL4~\cite{gordon:introduction:1993}, HOL Light~\cite{harrison:hol:2009}, and Isabelle~\cite{wenzel:isabelle:2008} intrinsically rely on state within their kernels.
When extending the logic with definition of a new constant, care must be taken to ensure that constants are not defined twice, lest, as pointed out by Wiedijk~\cite{wiedijk:stateless:2011}, we make our system inconsistent by defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$, then deducing $\vdash \mathtt{0 = 1}$ by transitivity and symmetry of equality.
This, in the systems mentioned above, is managed by a stateful kernel wherein a mutable database of existing constant names is maintained and queried prior to admitting a new constant definition.

Prevailing Haskell programming style attempts to avoid the use of imperative update and maintenance of implicit state, whenever possible.
Rather, explicit state tends to be passed around, with a monadic style of programming adopted to assuage the pain of such explicit state passing.
However, a na\"ive translation of an existing LCF-style kernel to Haskell using explicit state passing would be prone to inconsistencies without careful management of the many versions of the immutable state object floating around the system, as well as exposing a potentially cumbersome \textsc{api} to the programmer.
%A na\"ive translation would also radically change the \textsc{api} of the kernel presented to the programmer, making it cumbersome to use in comparison to the kernels of existing systems.

As Wiedijk noted, there is a simple method for writing a stateless HOL kernel, empirically only entailing a moderate slow down in the system when compared to those implemented using state, whilst retaining the elegance of the original stateful design.
Constants can be represented as a compound type consisting of their name as well as their definition, rather than simply their name as in e.g. HOL Light.
A constant $\mathtt{C}$ is now only equal to a constant $\mathtt{C'}$ if they share the same name \emph{and} definition.
Defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$ is now `safe'---at least from a point of view concerned purely with consistency of the logic---as a deduction of $\vdash \mathtt{0 = 1}$ is no longer possible.
A similar scheme is used to tag type formers, and the associated \emph{abstraction} and \emph{representation} constants, for new types with their defining theorems.
We adopt this method in the design of \mosquito.

\paragraph{Why develop another proof assistant?  Why choose HOL?}
By controlling state and adopting a monadic programming style, disavowing the use of exceptions to signal failure, and maintaining totality as far as possible, it is hoped the resulting system is easier to formalise in an existing proof assistant than systems such as HOL4 and HOL Light.
The clean-slate development of a new kernel also permits rapid experimentation, with e.g. tactics and backwards proof.
Concordantly, we started developing machinery atop the kernel, such as tactics and proof state representations, as well as conducting proofs of simple conjectures in the system.

HOL is a simple, well understood and widely implemented logic.
The logic can be described in a handful of inference rules.
Nevertheless, HOL has a proven track record in capturing large swathes of mathematics and computer science.

Further, by implementing HOL, one may leverage existing expertise and tools.
In time, proofs developed in other implementations may be imported and exported via OpenTheory~\cite{hurd:opentheory:2011}.
Similarly, automated proof tools already implemented and well tested may also be used in \mosquito~\cite{kumar:standalone:2012}.
By choosing to implement HOL, we may quickly develop a system by piggybacking on the work of those that have laboured before us.

Mosquito fills a niche: it's an implementation of vanilla HOL---potentially maintaining interoptability with existing HOLs via OpenTheory---using Haskell, not an ML dialect, as its metalanguage.

\paragraph{Related work}
Multiple implementations of HOLs and similar systems exist, though two existing systems are particularly closely related.
Wiedijk's Stateless HOL~\cite{wiedijk:stateless:2011} is a modification of HOL Light with a stateless kernel.
Austin and Alexander's HaskHOL~\cite{austin:stateless:2013} is a Wiedijk-style stateless implementation of HOL extended with System-F style polymorphism, also using Haskell as a metalanguage.

\begin{figure}
\begin{gather*}
\begin{prooftree}
(t \aeq u)
\justifies
\{\} \vdash t = u
\using\rulefont{alpha}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash u = t
\using\rulefont{symm}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash u = v
\justifies
\Gamma \cup \Delta \vdash t = v
\using\rulefont{trans}
\end{prooftree}
\\[1ex]
\begin{prooftree}
(t : \mathtt{Bool})
\justifies
\{ t \} \vdash t
\using\rulefont{assm}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t \quad \Delta \vdash u
\justifies
(\Gamma - u) \cup (\Delta - t) \vdash t = u
\using\rulefont{asym}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \ent t = u \quad \Delta \ent u
\justifies
\Gamma \cup \Delta \ent t
\using\rulefont{eqmp}
\end{prooftree}
\\[1ex]
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash \lam{a{:}\phi}t = \lam{a{:}\phi}u
\using\rulefont{abs}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash v = w
\justifies
\Gamma \cup \Delta \vdash t \cdot v = u \cdot w
\using\rulefont{comb}
\end{prooftree}
\quad
\begin{prooftree}
\phantom{h}
\justifies
\{\} \vdash \lam{a{:}\phi}t \cdot u = t[a/u]
\using\rulefont{beta}
\end{prooftree}
\\[1ex]
\begin{prooftree}
(a \not\in fv(t))
\justifies
\{\} \vdash \lam{a{:}\phi}(t \cdot a) = t
\using\rulefont{eta}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\vec{b}/\vec{u}] \vdash t[\vec{b}/\vec{u}]
\using\rulefont{inst}
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\vec{\alpha}/\vec{\phi}] \vdash t[\vec{\alpha}/\vec{\phi}]
\using\rulefont{tyinst}
\end{prooftree}
\end{gather*}
\caption{Inference rules for \mosquito's logic}
\label{fig.rules}
\end{figure}

\subsection*{\mosquito's logic}
\label{sect.logic}
\mosquito implements a similar higher-order logic to the HOL Light system.
Terms $t$, $u$, and so on, are terms of the simply-typed $\lambda$-calculus extended with constants.
The full derivation rules for the core logic are presented in Figure~\ref{fig.rules}.
Here, $\Gamma$ and $\Delta$ range over arbitrary contexts, $\{\}$ is the empty context, $fv(t)$ is the set of free variables of a term, $t[\vec{\alpha}/\vec{\phi}]$ is a parallel substitution instantiating types in terms, and $\Gamma[\vec{\alpha}/\vec{\phi}]$ is its pointwise extension to a context (similarly for parallel capture-avoiding substitutions $t[\vec{b}/\vec{u}]$).

\mosquito follows the well-worn LCF design philosophy.
The kernel exposes several abstract types: $\mathtt{Term}$, $\mathtt{Type}$ and $\mathtt{Theorem}$.
Modulo bugs in the design of Haskell or the GHC implementation the only way to construct a non-bottom inhabitant of $\mathtt{Theorem}$ is via appeal to the implementation of the rules in Figure~\ref{fig.rules}.

The kernel exports two primitive \emph{type formers}: $\mathtt{Bool}$, the Booleans, and $- \Rightarrow -$, the function space arrow.
Each type former is equipped with an \emph{arity}, a natural number detailing the number of types one must supply to the former to construct a new type.
Call a fully-applied type former a \emph{type}.
The primitive type \texttt{Bool} has arity 0, whilst the primitive type former $- \Rightarrow -$ has arity 2.
The kernel \textsc{api} ensures one may only construct `arity correct' types.

The kernel exports a single primitive constant, $- = -$, the equality constant, of type $\alpha \Rightarrow \alpha \Rightarrow \mathtt{Bool}$.
Equalities in Figure~\ref{fig.rules}, $t = u$, are therefore implemented merely as applications $(= t) u$ with syntactic sugar sprinkled atop.
Terms within the kernel are fully type annotated and only type-correct terms may be constructed.
Figure~\ref{fig.rules} should be interpreted as including a series of hidden typing constraints.
Under this scheme, the side condition stating $t$ must be a \emph{formula}---a term of type $\mathtt{Bool}$---in rule \rulefont{assm} makes sense, and the construction of a term $t = u$ necessarily implies that the terms $t$ and $u$ possess the same type.

\mosquito implements slightly stronger inference rules than the HOL Light kernel.
Rule \rulefont{alpha} bakes $\alpha$-equivalence, implemented using `nominal'-style swappings, into \mosquito's reflexivity rule.
In HOL Light a weakened form of \rulefont{eta} is axiomatised outwith the kernel.
Similarly, a weakened form of \rulefont{beta} is implemented in the HOL Light kernel.
The strengthened versions of $\eta$- and $\beta$-equality are then supplied later, as derived rules.
We choose to implement the full versions of these rules directly in \mosquito's kernel.

\mosquito's core higher-order logic may be extended in three ways.
A new constant may be defined as equal to an existing term, modulo restrictions on the free (type-)variables of that term.
A new inhabited type may be defined in provable bijection with a subset of an existing type.
Lastly, a formula may be asserted freeform as an axiom.
As axioms are `dangerous' from a consistency point of view, \mosquito, indelibly marks any theorem obtained directly or indirectly from an axiom.

\subsection*{Tactics and the proof state}
\label{sect.tactics.proof.state}

\mosquito supports forward proof directly by implementing the rules in Figure~\ref{fig.rules}.
For more complex proofs backward proof may be more amenable.
Backward proof (as well as a mixture of the two) is supported via \emph{tactics} operating on a \emph{proof state}.

A proof state consists of an incomplete derivation tree---a rose tree with an additional constructor $\mathtt{Hole}$ corresponding to a proof obligation---coupled with metadata.
Each $\mathtt{Hole}$ has a list of assumptions, the goal to prove at that hole, and a flag signalling whether that goal is \emph{selected} or \emph{unselected}.
Branches in the derivation tree are annotated by \emph{justification} functions.
These are used to replay the proof in a forward direction once completed, collapsing a derivation tree into a $\mathtt{Theorem}$.
The proof state \textsc{api} exposes three key functions, where $\mathtt{Inference}$ is a (monadic) type constructor used to signal failure:
\begin{lstlisting}
mkConjecture :: Term $\rightarrow$ Inference ProofState
qed :: ProofState $\rightarrow$ Inference Theorem
act :: ProofState $\rightarrow$ Tactic $\rightarrow$ Inference ProofState
\end{lstlisting}

A new proof state is constructed using $\mathtt{mkConjecture}$, taking a term as input and creating a derivation tree consisting of a selected hole.
This hole has no assumptions and has the input term as its goal.
The function fails if the input term is not a formula.

A theorem is obtained from a completed backward proof using $\mathtt{qed}$.
This function fails if the justification functions annotating the derivation tree do not correctly replay the proof in a forward direction, a theorem that fails to match the original conjecture is synthesised, or if the derivation tree remains incomplete.

Backwards proof is progressed via a tactic application using the $\mathtt{act}$ function.
Intuitively, tactics are applied to every selected goal at once, where zero or many goals may be selected at any one time.
A tactic applied via $\mathtt{act}$ must succeed on \emph{every} selected goal for $\mathtt{act}$ itself to succeed.
If a tactic succeeds at a goal it is transformed into a branch in the derivation tree with new selected holes as children, corresponding to the subgoals generated by the tactic.
This style of tactic application is similar in spirit to a style employed in Matita~\cite{asperti:matita:2011} and has the advantage of permitting the sharing of chunks of tactic driven proof across multiple goals.

In systems such as HOL Light, tactics are pieced together via tactic-valued functionals called tacticals.
In contrast, we embed the abstract syntax tree of a \emph{proof description language} explicitly as an algebraic data type:
\begin{lstlisting}
data Tactic
  = Apply PreTactic | ($\rightarrowtail$) Tactic Tactic | Id | FailWith String
  | Try Tactic | ($\oplus$) Tactic Tactic | Repeat Tactic
\end{lstlisting}

The semantics of proof descriptions is given by the $\mathtt{act}$ function.
Assume $\mathtt{p}$ is an arbitrary proof state.
Then:
\begin{itemize*}
\item
A call to $\mathtt{act\ p\ (FailWith\ err)}$ will result in failure, with $\mathtt{err}$ as a diagnostic error message, whilst a call to $\mathtt{act\ p\ Id}$ will always successfully return $\mathtt{p}$.
\item
A call to $\mathtt{act\ p\ (Try\ t)}$ first tries to apply $\mathtt{t}$, succeeding if this succeeds with the new proof state, or succeeding with the old proof state if this fails.
\item
A call to $\mathtt{act\ p\ (Repeat\ t)}$ tries to repeatedly (once or more) apply $\mathtt{t}$ to $\mathtt{p}$.
The call returns the last proof state successfully modified by $\mathtt{t}$.
\item
A call to $\mathtt{act\ p\ (t \rightarrowtail t')}$ will first try to transform $\mathtt{p}$ with $\mathtt{t}$.
If that succeeds, then the resulting state will be transformed by $\mathtt{t'}$, otherwise the call results in failure.
\item
A call to $\mathtt{act\ p\ (t \oplus t')}$ will first try to transform $\mathtt{p}$ with $\mathtt{t}$.
If this succeeds, then the new proof state is returned.
Otherwise, the proof state is modified by $\mathtt{t'}$, with the result of that modification being returned.
\end{itemize*}
$\mathtt{Apply}$ is perhaps the most interesting constructor of the $\mathtt{Tactic}$ data type, lifting a \emph{pretactic} into a tactic.
Intuitively, a pretactic is a function that edits a selected hole in the derivation tree.
A pretactic is supplied with the assumptions and goal to prove at that hole, and may either choose to fail with an error at that hole or succeed, returning a list of new subgoals which are spliced into the derivation tree as new holes.
Pretactics have an entirely `local' view of the derivation tree---they see only information present at a hole, and are not supplied with information about the rest of the tree.

As an example, we discuss the operation of $\mathtt{alphaPreTactic}$, which closes subgoals of the form $A_1 \ldots A_n \vdash_? t = u$, where $t$ and $u$ are $\alpha$-equivalent terms.
The pretactic is supplied with the assumptions list $A_1 \ldots A_n$ and with the goal to prove $t = u$ at that hole.
It pulls apart the goal, ensuring it is an equality, otherwise failing.
It then pulls apart the equality, ensuring the two equated terms are $\alpha$-equivalent, otherwise failing.
Should these preconditions be met, the pretactic returns an empty list of new subgoals, coupled with a justification function that makes use of the implementation of \rulefont{alpha} from Figure~\ref{fig.rules} to `reverse' its operation.

The $\mathtt{Tactic}$ embedding may be minimalist, but more complex tactics\footnote{We abuse language and refer to any $\mathtt{Tactic}$-valued Haskell function as a tactic.} may be written over this type.
For instance, the tactic $\mathtt{repeatN}$ repeatedly applies a tactic $\mathtt{m}$ times to a given proof state:
\begin{lstlisting}
repeatN :: Int $\rightarrow$ Tactic $\rightarrow$ Tactic
repeatN 0 tactic = Id
repeatN m tactic = tactic $\rightarrowtail$ repeatN (m - 1) tactic
\end{lstlisting}

More complex tactics `compile' down into more primitive tactics.
This sits in contrast to other systems where complex tactics are created by combining together primitive tactics with tacticals.

Treating tactics as data means tactics may be written that inspect other tactics.
The $\mathtt{act}$ function induces an equational theory on $\mathtt{Tactic}$: say that two tactics $\mathtt{t}$ and $\mathtt{t'}$ are equivalent if for any $\mathtt{p}$ their resulting transformation of $\mathtt{p}$ using $\mathtt{act}$ is identical.
Under this scheme, one would expect various equivalences, for example $\mathtt{Id \rightarrowtail t}$ and $\mathtt{t}$, or $\mathtt{Repeat\ (FailWith\ err)}$ and $\mathtt{FailWith\ err}$.
Following this, we may write a tactic $\mathtt{optimise}$ which rewrites its input according to these equational laws, producing an equivalent but `optimised' output.

Several tactics cause divergence of $\mathtt{act}$, for example $\mathtt{Repeat\ Id}$.
Adopting the position that diverging tactics are buggy, we may write a tactic $\mathtt{replaceBottoms}$ which inspects its input, replacing diverging tactics with $\mathtt{FailWith\ err}$, where $\mathtt{err}$ contains information useful in tracking down the source of the divergence.

Similarly, if we were interested in the small-step evolution of the proof state under the action of a given tactic, we could use a tactic `debugger', of type $\mathtt{ProofState \rightarrow Tactic \rightarrow Inference\ (ProofState,\ Maybe\ Tactic)}$.
For example, $\mathtt{debug}$, called on tactic $\mathtt{t \rightarrowtail t'}$ and proof state $\mathtt{p}$, first applies $\mathtt{t}$ to $\mathtt{p}$.
If this succeeds, it successfully returns the new proof state paired with $\mathtt{t'}$, otherwise failing.

\subsection*{Conclusions}
\label{sect.conclusions}

\mosquito is an implementation of HOL written in Haskell.
It features a Wiedijk-style stateless kernel, with a novel proof state and tactic representation built atop.
Some proofs of simple conjectures have been carried out in the system.

Several lines for further work remain.
How efficient \mosquito is at certifying large proofs remains unresolved, though this could be tested by importing existing proofs developed in other systems via OpenTheory.
\mosquito tactics are data that describes transformations of a proof state.
They may be inspected, modified and created like any other data.
How this representation limits or expands the set of tactics that can be written is an open question, and requires further work to answer.
Lastly, \mosquito has been written in a stylised manner, disavowing the use of global or implicit state, exceptions and other `non-functional' features in the hope that the resulting system would be a suitable target for machine checked proof of correctness.
Formalising \mosquito in an existing proof assistant and proving it correct remains for future work.

\bibliography{mulligan-mosquito-2013}

\end{document}