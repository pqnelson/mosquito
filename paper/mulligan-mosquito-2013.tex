\documentclass{llncs}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled]{beramono}
\usepackage{color}
\usepackage[T1]{fontenc}
\usepackage[colorlinks]{hyperref}
\usepackage{listings}
\usepackage{microtype}
\usepackage{prooftree}
\usepackage{tgpagella}
\usepackage{xspace}

\author{Dominic P. Mulligan}
\title{Mosquito: an implementation of higher-order logic}
\subtitle{(Rough diamond)}
\titlerunning{Mosquito}
\institute{Computer Laboratory, University of Cambridge}

\newcommand{\act}{\cdot}
\newcommand{\aeq}{=_\alpha}
\newcommand{\deffont}[1]{\textbf{#1}}
\newcommand{\ent}{\vdash}
\newcommand{\lam}[1]{\lambda{#1}.}
\newcommand{\mosquito}{Mosquito\xspace}
\newcommand{\rulefont}[1]{\ensuremath{(\mathbf{#1})}}
\newcommand{\tf}[1]{\mathsf{#1}}

\bibliographystyle{alpha}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  %deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=haskell,                 % the language of the code
  mathescape=true,
  %morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  %numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  %stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  belowskip=-1.125\baselineskip
}

\begin{document}

\maketitle

\begin{abstract}
We present \mosquito, a stateless, pure, largely total LCF-style implementation of classical higher-order logic with choice in Haskell.
We discuss details of the logic implemented, the kernel design and proof state and tactic representations.
We present some simple tactic-guided backwards proofs of conjectures over the Booleans in the system.
\end{abstract}

\mosquito is an LCF-style implementation of higher-order logic (HOL) written in Haskell.
\mosquito's kernel consists of 1000 lines of commented Haskell.
Some infrastructure such as proof state representations and tactics are built atop this.
More is in development.
\paragraph{Writing a HOL in Haskell}
Existing LCF-style implementations written in ML such as HOL4~\cite{gordon:introduction:1993}, HOL Light~\cite{harrison:hol:2009} and Isabelle~\cite{wenzel:isabelle:2008} intrinsically rely on state within their kernels.
When extending the logic with new constant definitions, care must be taken to ensure that constants are not defined twice, lest, as pointed out by Wiedijk~\cite{wiedijk:stateless:2011}, we make our system inconsistent by defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$, then deducing $\mathtt{0 = 1}$ by transitivity and symmetry of equality.
This, in the systems mentioned above, is managed by a stateful kernel wherein a mutable database of existing constant names is maintained.
The redefinition of existing constants is therefore avoided.

Prevailing Haskell programming style tends to avoid the use of imperative update and maintenance of implicit state, whenever possible.
Rather, explicit state tends to be passed around, with a monadic style of programming adopted to assuage the pain of explicit state passing.
However, a na\"ive translation of an existing LCF-style kernel to Haskell using explicit state passing would be prone to inconsistencies without careful management of the many versions of the immutable state object floating around the system.
A na\"ive translation would also radically change the \textsc{api} of the kernel presented to the programmer, making it cumbersome to use in comparison to the kernels of existing systems.

As Wiedijk noted, there is a simpler method for writing a stateless HOL kernel, which we adopt in \mosquito.
Constants can be represented as a compound type consisting of their name as well as their definition, rather than simply their name as in e.g. HOL Light.
A constant $\mathtt{C}$ is now only equal to a constant $\mathtt{C'}$ if they share the same name \emph{and} definition.
Defining a constant $\mathtt{C}$ to be both $\mathtt{0}$ and $\mathtt{1}$ now no longer entails that a deduction of $\mathtt{0 = 1}$ is possible, and consistency is therefore retained without appeal to explicit state passing.

\begin{figure}
\begin{gather*}
\begin{prooftree}
(t \aeq u)
\justifies
\{\} \vdash t = u
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash u = t
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash u = v
\justifies
\Gamma \cup \Delta \vdash t = v
\end{prooftree}
\quad
\begin{prooftree}
(t : \mathtt{Bool})
\justifies
\{ t \} \vdash t
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t \quad \Delta \vdash u
\justifies
(\Gamma - u) \cup (\Delta - t) \vdash t = u
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
\Gamma \vdash t = u
\justifies
\Gamma \vdash \lam{a{:}\phi}t = \lam{a{:}\phi}u
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t = u \quad \Delta \vdash v = w
\justifies
\Gamma \cup \Delta \vdash t \cdot v = u \cdot w
\end{prooftree}
\quad
\begin{prooftree}
\phantom{h}
\justifies
\{\} \vdash \lam{a{:}\phi}t \cdot u = t[a := u]
\end{prooftree}
\\[1.5ex]
\begin{prooftree}
(a \not\in fv(t))
\justifies
\{\} \vdash \lam{a{:}\phi}(t \cdot a) = t
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[b := u] \vdash t[b := u]
\end{prooftree}
\quad
\begin{prooftree}
\Gamma \vdash t
\justifies
\Gamma[\alpha := \phi] \vdash t[\alpha := \phi]
\end{prooftree}
\end{gather*}
\caption{Inference rules for \mosquito's logic}
\label{fig.rules}
\end{figure}

\paragraph{\mosquito's logic}
The basic axioms and rules of \mosquito's logic are described in Figure~\ref{fig.rules}.

\paragraph{Why develop another HOL?}
\mosquito was originally conceived as a kernel suitable for machine formalisation.
To a certain extent, that prototype got out of hand, and we started developing machinery atop the kernel, such as tactics, tacticals, and proof state representations, that surpassed our original intentions.
Writing proof assistants is fun.

The influence of this original idea persists, however, and \mosquito is purposefully written in a style which we think is amenable to machine-assisted proof of correctness.
The \mosquito kernel itself is stateless, as we have noted.
Exceptions, pervasive in other HOLs for handling errors, are completely avoided in favour of a monadic programming style.
We do not use mutable data structures.
Haskell's strict regimen of noting effects in types prevents us from arbitrarily mixing effectful and pure code.
Partiality is also kept to an absolute minimum, and to the best of our knowledge is present in only one place within the \mosquito code base.
Even here, if we chose to adopt more advanced Haskell type-level extensions, we could eliminate this partiality.

We chose to implement `vanilla HOL' rather than a more expressive logic.
In these matters, we believe a certain conservatism is to be preferred, as HOL is well understood, widely implemented, relatively simple but expressive enough to capture a large amount of mathematics and computer science.
\paragraph{Related work}
Austin and Alexander have previously implemented `HaskHOL', the kernel of a stateless HOL with quantified types \emph{a la} System F in Haskell~\cite{austin:stateless:2013}.
Wiedijk implemented a stateless version of HOL Light and did empirical tests on the performance differences between the two systems~\cite{wiedijk:stateless:2011}.
To the best of our knowledge, \mosquito is the first implementation of vanilla HOL in Haskell.

\section{Logic}
\label{sect.logic}

\section{Tactics and the proof state}
\label{sect.tactics.proof.state}

\subsection{Tactics, tacticals and stackticals}
\label{subsect.tactics.tacticals.modifying.proof.state}

\section{Example forward and backward proof}
\label{subsect.example.forward.backward.proof}

We present a simple example of forwards and backwards proof in the system being used together to prove a simple conjecture.

Let $\top$ be defined at type $\mathtt{Bool}$ as $\lam{b{:}\mathtt{Bool}}b = \lam{b{:}\mathtt{Bool}}b$.
Let the universal quantifier $\forall$ be defined at type $(\alpha \rightarrow \mathtt{Bool}) \rightarrow \mathtt{Bool}$ as $\forall = \lam{P{:}\alpha \rightarrow \mathtt{Bool}}(P = \lam{a:{\alpha}}\top)$.
Let $\mathtt{trueC}$ refer to the constant $\top$ and $\mathtt{trueD}$ refer to the defining theorem $\vdash \top = \lam{b{:}\mathtt{Bool}}b = \lam{b{:}\mathtt{Bool}}b$.
Likewise with universal quantification and the (Haskell) constants $\mathtt{forallC}$ and $\mathtt{forallD}$.

We ultimately aim to show that $\vdash \forall{t{:}\alpha}. t = t$.
Note this is different from the primitive HOL \rulefont{refl} rule implemented in the \mosquito kernel.

We first show that given $\Gamma \vdash p$ we can derive $\Gamma \vdash p = \top$.
We do this in a forward proof style, building a derivation by direct appeal to the basic HOL axioms and rules implemented in the \mosquito system:
\begin{lstlisting}
trueEqI :: Theorem $\rightarrow$ Inference Theorem
trueEqI theorem = do
  let p =  conclusion theorem
  assmP $\leftarrow$ assume p                        $\textrm{--- } \{ p \} \vdash p$
  trueI $\leftarrow$ trueI                           $\textrm{--- } \emptyset \vdash \top$
  das1  $\leftarrow$ deductAntiSymmetric assmP trueI $\textrm{--- } \{ p \} \vdash p = \top$
  let c =  conclusion das1
  assmC $\leftarrow$ assume c                        $\textrm{--- } \{ p = \top \} \vdash p = \top$
  eqE   $\leftarrow$ trueEqE assmC                   $\textrm{--- } \{ p = \top \} \vdash p$
  das2  $\leftarrow$ deductAntiSymmetric das1 eqE    $\textrm{--- } \emptyset \vdash p = (p = \top)$
  symm  $\leftarrow$ symmetry das2                   $\textrm{--- } \emptyset \vdash (p = \top) = p$
  equalityModusPonens symm theorem         $\textrm{--- } \Gamma \vdash p$
\end{lstlisting}
Here, we have annotated the Haskell source code to make clear what is happening.
The function $\mathtt{conclusion}$ returns the conclusion of a theorem.
The constant $\mathtt{trueI}$ is a theorem stating $\vdash \top$.
The function $\mathtt{trueEqE}$ transforms a derivation of $\Gamma \vdash p = \top$ into one of $\Gamma \vdash p$.
The functions $\mathtt{assume}$, $\mathtt{deductAntiSymmetric}$, $\mathtt{symmetry}$ and $\mathtt{equalityModusPonens}$ are all basic HOL rules and axioms implemented in the \mosquito kernel.

Using this theorem, we can derive a tactic that transforms an obligation to prove $\Gamma \vdash p = \top$ into an obligation to prove $\Gamma \vdash p$ in a backwards, tactic-driven proof:
\begin{lstlisting}
trueEqIPreTac :: PreTactic
trueEqIPreTac assms concl = do
  trueC $\leftarrow$ trueC
  (left, right) $\leftarrow$ fromEquality concl
  if right $\equiv$ trueC then
    return $\$$ Refine (\[t] $\rightarrow$ trueEqI t) [Open assms left]
  else
    fail "`trueEqITac'"
trueEqITac :: Tactic
trueEqITac =
  apply trueEqIPreTac $\oplus$ (symmetryTac $\rightarrowtail$ apply trueEqIPreTac)
\end{lstlisting}

\begin{lstlisting}
reflexivityThm :: Inference Theorem
reflexivityThm = do
  prf <- conjecture "reflexivity-thm" conj
  prf <-
    by [
      unfoldTac forallD
    , reductionTac
    , abstractTac
    , trueEqITac
    , autoBase
    ] prf
  qed prf
\end{lstlisting}

\section{Conclusions and future work}
\label{sect.conclusions}

\bibliography{mulligan-mosquito-2013}

\end{document}